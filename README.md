# Facial-Landmark

Description: This program goal is to take images from KTP, Driver’s License, passport and other form of identification card and crop the picture on that ID. With that picture, it would measure the distance from one point towards another and return It in a data frame. This would also run through all images located in a specific directory, return the crop image in a specific 
folder of your choosing and further on would store the measurement into a data frame. The program has a higher success rate when the image of the ID is at least 500 by 500 pixel.

Program Flow:
The program starts with importing the one listed, installation of cv2, numpy, dlib and pandas is required for the program to run. It starts by listing down what is listed and stored in the specific directory folder that you want the images to be read and sorted in ascending order and storing it all in ‘x’. For mac, there is “.DS_Store” so removing it from the list is required. Declaration of the data frame that would be used is declared along with the list that would store both the images that ‘success’ and ‘fail' in separate list. The first for loop would be the main loop, allowing the program to go through every name in x, counter would be the current name in the list. ‘a’ would store the image that is being read using cv2.imread and the data path of where the image is being stored along with the counter which is the current image being looked at in the loop. 

The first method would be ‘detect_faces (a)’ which would take the stored current image to the method. The purpose of this specific method is to crop the image that is currently being pass through the method by the face in the ID and return it with a flagger and also store it towards a specific folder. In the parameter of detect_faces, there would be the test_image and the scaleFactor which would be the sensitivity of the program running. The method starts by importing the haarcascade model that would identify if there is a face in that specific ID, the haarcascade classifier is stored in cascade. A duplicate of the image is created so that the original image would still be intact and not modified. The image_copy would then be converted towards the gray scale and stored at gray_image, this would allow the cascade.detectMultiScale to find the image and save it with the coordinates in the ID and save it too faces_rect. The next for loop is to draw a rectangle around the image, crop the image base on the points given and the rectangle drawn and push it out towards a directory saving the crop image. This method would return faces_rect and image_copy. Onwards, there is a if statement checking if ‘b’ where detect_faces is stored if it is empty, if the Len is less than 1 which means 0, then the list is empty because the image was failed to be detected, so it would append towards the ‘fail’ list and continue, ending this round of the loop and going towards the next image right away. The else statement would catch the rest, which means if the image is detected and pass through, then it would go on towards the next method. The next method would be the landmark_placer which would take the result of detect_faces but only image_copy and not the faces_rect. Faces_rect acts as a flagger to check if the index that is being pass contains the image or is just simply an empty set. 

The landmark_placer method uses the model called shape_predictor_68_face_landmarks.dat to predict the landmarks on the crop image and place 68 points through out the face, each point would represent a different point on the face and numbers ranging from a certain number to a certain number would represent the points at that specific landmark. The method starts by creating a list ‘fulllist and a duplicate of the image that is pass through to this method. Storing the dlib method frontal face detector at ‘detector’ and storing the shape predictor model at ‘predictor’ for calling it in the future making it easier to reference. The image would then be converted to the gray scale and stored at gray, the ‘detector’ then would get the face located on the image that is being crop and plot the coordinates at x1, x2, y1, y2. The try would then use the predictor and place each landmark in the the full list along with a flagger and the landmark would use circles as markers. The except would Cath the unbound local error during the case if the array is empty, it would just pass. This method would return faces and fulllist, faces being the flagger and fulllist being where the coordinates are all stored. All from the landmark_placer method would then be stored at c. Another if statement would check the faces located in c as the flagger if the current image is empty or not, if it is empty it would add the name of the failed image to the ‘fail’ list and continue on towards the next image ending this round of the for loop.

The else statement would continue on with the calculation for the images that are stored properly and is contained in c.  The next two methods ‘distance_cal’ and ‘point_cal’ take fulllist and calculate the distance from the points. ‘Distance_cal’ would calculate the center point of each landmark, so for the eye, the list would look for the left furthest point of the left eye and calculate the distance towards the right furthest point of the left eye. After calculating the center point, it would append towards a list which would be added towards a data frame. ‘Point_cal’ purpose would be to calculate the distance of all the point, but for the eyes and nose, then calculate the center and calculate the distance from the center instead of every single point. First, the method would start by dividing the fulllist to know from point a till point b belongs to which landmark. For the eyes and nose, just add the two ends and divide it by 2 to get the mid point. The for loop then would go through all the points and center of eyes and nose and calculate the distance using the Euclidean distance from every points in the full list with all the other points. Then all the distance would be stored onto one list which would be turn into a data frame. Further on, the data frame would be given a header for each column and then concat by the index, and at the end the success would be appended towards the success list. At the end, the data would be all stored at df_temp and both success and fail would consist and count each of those. 

Model Used:
In this program, there are two main models used and one mathematical formula used, they are:
-  haarcascade_frontalface_default.xml
-  shape_predictor_68_face_landmarks.dat
-  euclidean distance
NOTE: These are existing models available online, I use them to create the program but it is not my mathematical model. Also the model "shape_predictor_68_face_landmarks.dat" was too large in size to be uploaded to the repository

